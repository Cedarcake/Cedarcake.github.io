<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>博客</title>
    <url>/blog/2020/04/22/123/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>欢迎阅读我的博客，博客搭建时间： 2020/4/22<br>部署于： Gitee pages (另外部署于 Github : cedarcake.github.io )<br>基于框架： Hexo<br>主题： Next<br>美化： 个人<br>今后的学习记录都会呈现于此，<br>欢迎大家互相学习。</p>
<a id="more"></a>
<h2 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h2><p>QQ:1248558099<br><img src="../../../../images/%E9%A6%96%E7%AB%A01.jpg" alt="a"><br>(4/24修改)</p>
]]></content>
      <tags>
        <tag>前言</tag>
      </tags>
  </entry>
  <entry>
    <title>博客</title>
    <url>/blog/2020/04/22/4-22%E9%A6%96%E7%AB%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>欢迎阅读我的博客，博客搭建时间： 2020/4/22<br>部署于： Github pages (gitee: cedar_i.gitee.io)<br>基于框架： Hexo<br>主题： Next<br>美化： 个人<br>今后的学习记录都会呈现于此，<br>欢迎大家互相学习。</p>
<a id="more"></a>
<h2 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h2><p>QQ:1248558099<br><img src="../../../../../../images/tx.jpg" alt="a"></p>
]]></content>
      <tags>
        <tag>前言</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-单链表</title>
    <url>/blog/2020/04/22/4-24%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="数据结构-单链表"><a href="#数据结构-单链表" class="headerlink" title="数据结构-单链表"></a>数据结构-单链表</h3><h1 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h1><p>单链表是一种链式存取的数据结构，用一组地址任意的存储单元存放线性表中的数据元素。<br>链表中的数据是以结点来表示的<br>每个结点的构成:元素(数据元素的映象) + 指针(指示后继元素存储位置)<br>元素就是存储数据的存储单元，指针就是连接每个结点的地址数据</p>
<h1 id="链表定义"><a href="#链表定义" class="headerlink" title="链表定义"></a>链表定义</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef int ElemType;</span><br><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	struct Node *next;</span><br><span class="line">&#125;LNode,*LinkList;&#x2F;&#x2F;定义单链表结点结构体</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h1 id="初始化单链表"><a href="#初始化单链表" class="headerlink" title="初始化单链表"></a>初始化单链表</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int ListInit_L(LinkList &amp;L) &#x2F;&#x2F;初始化单链表，建立一个带头结点的单链表</span><br><span class="line">&#123;</span><br><span class="line">	L &#x3D; (LinkList)malloc(sizeof(Node));</span><br><span class="line">	if(!L) exit(0);&#x2F;&#x2F;创建失败退出.除非系统出错- -</span><br><span class="line">	L-&gt;next&#x3D;NULL;</span><br><span class="line">	L-&gt;data&#x3D;-1;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void ListInit_Creadhead(LinkList &amp;L) &#x2F;&#x2F;头插法</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	LinkList p,q;</span><br><span class="line">	p&#x3D;L;</span><br><span class="line">	printf(&quot;输入n和n个数字：\n&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	printf(&quot;输入%d个数字\n&quot;,n);</span><br><span class="line">	while(n--)</span><br><span class="line">	&#123;</span><br><span class="line">		q&#x3D;(LinkList)malloc(sizeof(LNode));</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;q-&gt;data);</span><br><span class="line">		q-&gt;next&#x3D;p-&gt;next;</span><br><span class="line">		p-&gt;next&#x3D;q;</span><br><span class="line">		p&#x3D;q;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void ListInit_Creadtail(LinkList &amp;L) &#x2F;&#x2F;尾插法</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	LinkList p,s;</span><br><span class="line">	p&#x3D;L;</span><br><span class="line">	printf(&quot;输入n和n个数字：\n&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	printf(&quot;输入%d个数字\n&quot;,n);</span><br><span class="line">	while(n--)</span><br><span class="line">	&#123;</span><br><span class="line">		s&#x3D;(LinkList)malloc(sizeof(Node));</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;s-&gt;data);</span><br><span class="line">		s-&gt;next&#x3D;p-&gt;next;</span><br><span class="line">		p-&gt;next&#x3D;s;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="按位插入"><a href="#按位插入" class="headerlink" title="按位插入"></a>按位插入</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void LinkedList_Insert(LinkList &amp;L,int i,int key) &#x2F;&#x2F;按位插入</span><br><span class="line">&#123;</span><br><span class="line">	LinkList p,s;&#x2F;&#x2F;定义所需结点</span><br><span class="line">	p&#x3D;L;</span><br><span class="line">	int j&#x3D;1;</span><br><span class="line">	while(j&lt;i)</span><br><span class="line">	&#123;</span><br><span class="line">		p&#x3D;p-&gt;next;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	s &#x3D; (LinkList)malloc(sizeof(Node));</span><br><span class="line">	s-&gt;data&#x3D;key;</span><br><span class="line">	s-&gt;next&#x3D;p-&gt;next;</span><br><span class="line">	p-&gt;next&#x3D;s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="删除i位置上的元素"><a href="#删除i位置上的元素" class="headerlink" title="删除i位置上的元素"></a>删除i位置上的元素</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void LinkList_delete(LinkList L, int i)&#x2F;&#x2F;删除i位置上的元素  </span><br><span class="line">&#123;</span><br><span class="line">	int j;</span><br><span class="line">	LinkList p, q;</span><br><span class="line">	p &#x3D; L;</span><br><span class="line">	j &#x3D; 1;</span><br><span class="line">	while (j&lt;i)</span><br><span class="line">	&#123;</span><br><span class="line">		p &#x3D; p-&gt;next;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	q &#x3D; p-&gt;next;</span><br><span class="line">	p-&gt;next &#x3D; p-&gt;next-&gt;next;</span><br><span class="line">	free(q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="全代码"><a href="#全代码" class="headerlink" title="全代码"></a>全代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">typedef int ElemType;</span><br><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	struct Node *next;</span><br><span class="line">&#125;LNode,*LinkList;&#x2F;&#x2F;定义单链表结点结构体</span><br><span class="line"></span><br><span class="line">void LinkList_Print(LinkList L)&#x2F;&#x2F;输出单链表和链表长度</span><br><span class="line">&#123;</span><br><span class="line">	int num &#x3D; 0;</span><br><span class="line">	LinkList p;</span><br><span class="line">	p&#x3D;L-&gt;next;</span><br><span class="line">	while(p)</span><br><span class="line">	&#123;</span><br><span class="line">		num++;</span><br><span class="line">		printf(&quot;%d &quot;,p-&gt;data);</span><br><span class="line">		p&#x3D;p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;长度为：%d\n&quot;,num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LinkList_Find(LinkList L,int x)&#x2F;&#x2F;查找第x个位置的值</span><br><span class="line">&#123;</span><br><span class="line">	LinkList p;</span><br><span class="line">	p&#x3D;L;</span><br><span class="line">	int i&#x3D;1;</span><br><span class="line">	while(p-&gt;next &amp;&amp;p-&gt;next-&gt;data!&#x3D;x)</span><br><span class="line">	&#123;</span><br><span class="line">		p&#x3D;p-&gt;next;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	if(p-&gt;next)</span><br><span class="line">		printf(&quot;%d的位置为：%d\n&quot;,x,i);</span><br><span class="line">	else</span><br><span class="line">		printf(&quot;没找到!!\n\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LinkList_sort(LinkList &amp;L)</span><br><span class="line">&#123;</span><br><span class="line">	LinkList p,q;</span><br><span class="line">	int temp;</span><br><span class="line">	for(p&#x3D;L;p-&gt;next!&#x3D;NULL;p&#x3D;p-&gt;next)</span><br><span class="line">	&#123;</span><br><span class="line">		for(q&#x3D;p-&gt;next;q!&#x3D;NULL;q&#x3D;q-&gt;next)</span><br><span class="line">		&#123;</span><br><span class="line">			if(p-&gt;data&gt;q-&gt;data)</span><br><span class="line">			&#123;</span><br><span class="line">				temp&#x3D;p-&gt;data;</span><br><span class="line">				p-&gt;data&#x3D;q-&gt;data;</span><br><span class="line">				q-&gt;data&#x3D;temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;排序成功！\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void LinkList_Deletesame(LinkList L)&#x2F;&#x2F;删除相同的元素</span><br><span class="line">&#123;</span><br><span class="line">	LinkList_sort(L);&#x2F;&#x2F;排序........</span><br><span class="line">	LinkList p,q,s;</span><br><span class="line">	p&#x3D;L;</span><br><span class="line">	q&#x3D;L-&gt;next;</span><br><span class="line">	while(q-&gt;next)</span><br><span class="line">	&#123;</span><br><span class="line">		if(q-&gt;data&#x3D;&#x3D;q-&gt;next-&gt;data)</span><br><span class="line">		&#123;</span><br><span class="line">			p-&gt;next&#x3D;q-&gt;next;</span><br><span class="line">			s&#x3D;q;</span><br><span class="line">			q&#x3D;q-&gt;next;</span><br><span class="line">			free(s);</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			p&#x3D;p-&gt;next;</span><br><span class="line">			q&#x3D;q-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;删除成功!!!!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int ListInit_L(LinkList &amp;L) &#x2F;&#x2F;初始化单链表，建立一个带头结点的单链表</span><br><span class="line">&#123;</span><br><span class="line">	L &#x3D; (LinkList)malloc(sizeof(Node));</span><br><span class="line">	if(!L) exit(0);&#x2F;&#x2F;创建失败退出.除非系统出错- -</span><br><span class="line">	L-&gt;next&#x3D;NULL;</span><br><span class="line">	L-&gt;data&#x3D;-1;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void ListInit_Creadhead(LinkList &amp;L) &#x2F;&#x2F;头插法</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	LinkList p,q;</span><br><span class="line">	p&#x3D;L;</span><br><span class="line">	printf(&quot;输入n和n个数字：\n&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	printf(&quot;输入%d个数字\n&quot;,n);</span><br><span class="line">	while(n--)</span><br><span class="line">	&#123;</span><br><span class="line">		q&#x3D;(LinkList)malloc(sizeof(LNode));</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;q-&gt;data);</span><br><span class="line">		q-&gt;next&#x3D;p-&gt;next;</span><br><span class="line">		p-&gt;next&#x3D;q;</span><br><span class="line">		p&#x3D;q;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void ListInit_Creadtail(LinkList &amp;L) &#x2F;&#x2F;尾插法</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	LinkList p,s;</span><br><span class="line">	p&#x3D;L;</span><br><span class="line">	printf(&quot;输入n和n个数字：\n&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	printf(&quot;输入%d个数字\n&quot;,n);</span><br><span class="line">	while(n--)</span><br><span class="line">	&#123;</span><br><span class="line">		s&#x3D;(LinkList)malloc(sizeof(Node));</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;s-&gt;data);</span><br><span class="line">		s-&gt;next&#x3D;p-&gt;next;</span><br><span class="line">		p-&gt;next&#x3D;s;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void LinkedList_Insert(LinkList &amp;L,int i,int key) &#x2F;&#x2F;按位插入</span><br><span class="line">&#123;</span><br><span class="line">	LinkList p,s;&#x2F;&#x2F;定义所需结点</span><br><span class="line">	p&#x3D;L;</span><br><span class="line">	int j&#x3D;1;</span><br><span class="line">	while(j&lt;i)</span><br><span class="line">	&#123;</span><br><span class="line">		p&#x3D;p-&gt;next;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	s &#x3D; (LinkList)malloc(sizeof(Node));</span><br><span class="line">	s-&gt;data&#x3D;key;</span><br><span class="line">	s-&gt;next&#x3D;p-&gt;next;</span><br><span class="line">	p-&gt;next&#x3D;s;</span><br><span class="line">&#125; </span><br><span class="line">void LinkList_delete(LinkList L, int i)&#x2F;&#x2F;删除i位置上的元素  </span><br><span class="line">&#123;</span><br><span class="line">	int j;</span><br><span class="line">	LinkList p, q;</span><br><span class="line">	p &#x3D; L;</span><br><span class="line">	j &#x3D; 1;</span><br><span class="line">	while (j&lt;i)</span><br><span class="line">	&#123;</span><br><span class="line">		p &#x3D; p-&gt;next;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	q &#x3D; p-&gt;next;</span><br><span class="line">	p-&gt;next &#x3D; p-&gt;next-&gt;next;</span><br><span class="line">	free(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LinkList_find2(LinkList L, int i)&#x2F;&#x2F;查找i位置上的元素  </span><br><span class="line">&#123;</span><br><span class="line">	int j&#x3D;0;</span><br><span class="line">	LinkList p;</span><br><span class="line">	p &#x3D; L;</span><br><span class="line">	while (j&lt;i)</span><br><span class="line">	&#123;</span><br><span class="line">		p &#x3D; p-&gt;next;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	if(p!&#x3D;NULL)</span><br><span class="line">		printf(&quot;第%d位置上的值为：%d\n&quot;,i,p-&gt;data);</span><br><span class="line">	else</span><br><span class="line">		printf(&quot;元素不存在&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void menu()</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	printf(&quot;根据按键选择相应的操作：\n&quot;);</span><br><span class="line">	printf(&quot;1、输出单链表及其长度\n&quot;);</span><br><span class="line">	printf(&quot;2、查找元素在表中的位置\n&quot;);</span><br><span class="line">	printf(&quot;3、删除第i个结点:\n&quot;);</span><br><span class="line">	printf(&quot;4、删除相同的值（自动排序）作业之外:\n&quot;);</span><br><span class="line">	printf(&quot;5、在位置i 插入新的元素key\n&quot;);</span><br><span class="line">	printf(&quot;0、退出:\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	int ID,x;</span><br><span class="line">	LinkList L;</span><br><span class="line">	ListInit_L(L);  &#x2F;&#x2F;带头结点的初始化</span><br><span class="line">	printf(&quot;请选择你要插入的方式\n1、头插法\n2、尾插法\n&quot;);  &#x2F;&#x2F;选择插入方式</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;ID);</span><br><span class="line">	switch(ID)</span><br><span class="line">	&#123;</span><br><span class="line">		case 1:ListInit_Creadhead(L);break;  &#x2F;&#x2F;头插法</span><br><span class="line">		case 2:ListInit_Creadtail(L);break;	 &#x2F;&#x2F;尾插法</span><br><span class="line">	&#125;</span><br><span class="line">	menu();  &#x2F;&#x2F;菜单</span><br><span class="line">	while(ID)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;ID);</span><br><span class="line">		switch(ID)</span><br><span class="line">		&#123;</span><br><span class="line">		case 1:LinkList_Print(L);	&#x2F;&#x2F;表长和 输出函数。弄一起了</span><br><span class="line">			break;</span><br><span class="line">		case 2:</span><br><span class="line">			printf(&quot;请输入要查找的元素:\n&quot;);</span><br><span class="line">			scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">			LinkList_Find(L,x);</span><br><span class="line">			break;</span><br><span class="line">		case 3:</span><br><span class="line">			printf(&quot;请输入要删除的位置:\n&quot;);</span><br><span class="line">			scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">			LinkList_delete(L,x);  &#x2F;&#x2F;删除操作</span><br><span class="line">			break;</span><br><span class="line">		case 4:LinkList_Deletesame(L); &#x2F;&#x2F;删除相同的值.加强版本。自动排序。。不在作业范围内</span><br><span class="line">			break;</span><br><span class="line">		case 5:</span><br><span class="line">			int a,b;</span><br><span class="line">			printf(&quot;请输入你要插入的位置&quot;);&#x2F;&#x2F;位插</span><br><span class="line">			scanf(&quot;%d&quot;,&amp;a);</span><br><span class="line">			printf(&quot;请输入你要插入的值&quot;);</span><br><span class="line">			scanf(&quot;%d&quot;,&amp;b);</span><br><span class="line">			LinkedList_Insert(L,a,b);</span><br><span class="line">			break;</span><br><span class="line">		case 6:</span><br><span class="line">			printf(&quot;请输入要查找的位置:\n&quot;);&#x2F;&#x2F;查找位置</span><br><span class="line">			scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">			LinkList_find2(L,x); </span><br><span class="line">			break;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!-- 
			<script>
				console.error("Error: [hexo-tag-aplayer] Specified asset file not found (夏天的风.png)");
			</script> -->
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>数据结构</tag>
        <tag>单链表</tag>
      </tags>
  </entry>
  <entry>
    <title>5-7二叉树的应用</title>
    <url>/blog/2020/05/07/5-7%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="定义二叉树结点和结点指针"><a href="#定义二叉树结点和结点指针" class="headerlink" title="定义二叉树结点和结点指针"></a>定义二叉树结点和结点指针</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct BiTNode</span><br><span class="line">&#123;</span><br><span class="line">    char data;</span><br><span class="line">    struct BiTNode *lchild,*rchild; &#x2F;&#x2F;定义出左孩子和右孩子</span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="创建二叉树"><a href="#创建二叉树" class="headerlink" title="创建二叉树"></a>创建二叉树</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void CreateBiTree(BiTree *T) &#x2F;&#x2F;二叉树的创建（前序输入）</span><br><span class="line">&#123;</span><br><span class="line">    char ch;        </span><br><span class="line">    scanf(&quot;%c&quot;,&amp;ch);  &#x2F;&#x2F;记录输入的值</span><br><span class="line">    if(ch&#x3D;&#x3D;&#39;.&#39;)  &#x2F;&#x2F;如果值为 . 则输入的为空值，并退出递归</span><br><span class="line">        *T&#x3D;NULL;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        *T&#x3D;(BiTree)malloc(sizeof(BiTNode));   &#x2F;&#x2F;为T分配空间</span><br><span class="line">        if(*T&#x3D;&#x3D;NULL)&#x2F;&#x2F;if (!*T)                &#x2F;&#x2F;保险判断，以防进入的为空值</span><br><span class="line">            exit(-1);                         &#x2F;&#x2F;退出递归</span><br><span class="line">        (*T)-&gt;data&#x3D;ch;                        &#x2F;&#x2F;将值赋值到树中</span><br><span class="line">        CreateBiTree(&amp;(*T)-&gt;lchild);          &#x2F;&#x2F;递归左孩子</span><br><span class="line">        CreateBiTree(&amp;(*T)-&gt;rchild);          &#x2F;&#x2F;递归右孩子</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
</search>
